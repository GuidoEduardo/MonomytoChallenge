// <auto-generated />
#nullable enable
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using MonomytoChallenge.Configurations;
using MonomytoChallenge.Data;
using MonomytoChallenge.Models;


namespace MonomytoChallenge.Controllers
{
    // Configuração de controller e construção de rotas
    // da API para gerenciamento de entidade Produto
    [Route("api/[controller]")]
    [ApiController]
    public class ProdutoController : ControllerBase
    {
        private readonly ApiContext context;

        public ProdutoController(ApiContext context)
        {
            this.context = context;
        }

        [HttpGet]
        [Route("{id?}")]
        public async Task<JsonResult> Get(
            Guid? id = null, 
            string? searchNome = "", 
            int? minTeor = null,
            int? maxTeor = null)
        {
            // Inicia a construção da consulta para Produtos
            IQueryable<Produto> produtos = this.context.Produtos;

            if (id.HasValue)
            {
                try
                {
                    // Se consultado por Id, retorna apenas o produto consultado
                    return new JsonResult(Ok(
                        await produtos.AsNoTracking().FirstAsync(p => p.Id == id.Value)
                    ));
                }
                catch (Exception e)
                {
                    return new JsonResult(NotFound(e.Message));
                }
            }

            // Filtragem por nome - case insensitive
            if (!string.IsNullOrEmpty(searchNome))
            {
                // Consulta a entidade Produto em busca do nome obtido
                produtos = produtos.Where(p => p.Nome!.ToLower().Contains(searchNome.ToLower()));
            }

            // Filtragem de teor -> Min
            if (minTeor.HasValue)
            {
                produtos = produtos.Where(p => p.TeorAlcoolico >= minTeor);
            }

            // Filtragem de teor -> Max
            if (maxTeor.HasValue)
            {
                produtos = produtos.Where(p => p.TeorAlcoolico <= maxTeor);
            }

            try
            {
                // Retorna todos os produtos filtrados com uma resposta de sucesso
                return new JsonResult(Ok(await produtos.AsNoTracking().ToListAsync()));
            }
            catch (Exception e)
            {
                return new JsonResult(BadRequest(e.Message));
            }
        }

        // Relatório de vendas por produto 
        [HttpGet]
        [Route("Report")]
        public async Task<JsonResult> Report(string? sortValor = null, string? sortQt = null)
        {
            // Inicia a construção da consulta para Produtos
            IQueryable<Produto> produtos = this.context.Produtos;

            // Realiza a soma de valor total e quantidade
            var produtosOrd = produtos.Select(p => new ProdutoReport
                {
                    Produto = p,
                    TotalValor = p.Vendas!.Sum(i => i.PrecoUnitario * i.Quantidade),
                    TotalQuantidade = p.Vendas!.Sum(i => i.Quantidade),
                }
            );

            // Realiza ordenação por Valor Total
            if(sortValor == "desc")
            {
                produtosOrd = produtosOrd.OrderByDescending(p => p.TotalValor);
            }
            else if (sortValor == "asc")
            {
                produtosOrd = produtosOrd.OrderBy(p => p.TotalValor);
            }

            // Realiza ordenação por Quantidade Total
            if (sortQt == "desc")
            {
                produtosOrd = produtosOrd.OrderByDescending(p => p.TotalQuantidade);
            }
            else if (sortQt == "asc")
            {
                produtosOrd = produtosOrd.OrderBy(p => p.TotalQuantidade);
            }

            try
            {
                // Retorna todos os produtos ordenados com uma resposta de sucesso
                return new JsonResult(Ok(await produtosOrd.AsNoTracking().ToListAsync()));
            }
            catch (Exception e)
            {
                return new JsonResult(BadRequest(e.Message));
            }
        }
    }
}
